<html>
  <head>
    <meta charset="utf-8">
    <title>练习本</title>
  </head>
  <body>
    <p id="p1">测试</p>
    <div>
        <span id='123' class="pp">test id = '123'</span>
        <span class="pp">test</span>
        <span class="pp">test</span> </br>
        <!-- 实现一段脚本，使得点击对应链接alert出相应的编号 -->
        <!-- 经典闭包 2018-11-28 -->
        <a href='#'> 第一个链接 </a> </br>
        <a href='#'> 第二个链接 </a> </br>
        <a href='#'> 第三个链接 </a> </br>
        <a href='#'> 第四个链接 </a> </br>
    </div>
    <script>
      /** 笔试题 */
      /** ------------------------------------- START function 笔试题 --------------------------------------------------------*/
      /* 2018-11-20 一 考察this(与blog说明不符) https://www.cnblogs.com/zichi/p/4359786.html  */
      function testThis() {
        var length = 10;
        function fn() {
          console.log(this.length)
        }
        var obj = {
          length: 5,
          method: function(fn) {
            fn()
            arguments[0]()
            console.log('arguments:', arguments)
          }
        }
        obj.method(fn, 1)
      }
      /* 2018-11-20 二 var和函数的提前声明 https://www.cnblogs.com/zichi/p/4359786.html  */
      /* 解读：我们知道var和function是会提前声明的，而且function是优先于var声明的（如果同时存在的话），
        所以提前声明后输出的a是个function，然后代码往下执行a进行重新赋值了，故第二次输出是2。
      */
      function testVar(a) {
        console.log('1- ' + a)
        var a = 10
        function a () {}
        console.log('2- ' + a)
      }

      /* 2018-11-20 三 局部变量和全局变量 https://www.cnblogs.com/zichi/p/4359786.html  */
      /**
        1- 以下代码在测试时 放开注释即可
        解读：输出：10 报错 30　　
    　　这是个我犯了很久的错误，很长一段时间我都以为{...}内的新声明的变量是局部变量，
        后来我才发现function内的新声明的变量才是局部变量，而没有用var声明的变量在哪里都是全局变量。
        再次提醒切记只有function(){}内新声明的才能是局部变量，while{...}、if{...}、for(..) 之内的都是全局变量（除非本身包含在function内）。
      */
      var a3 = 10;

      function fn3() {
        // var b3 = 20;
        c3 = 30;
      }

      fn3()

      if (true) {
        // let则使得if / for / while中的语句都具有局域性
        let d3 = 40
      }

      // console.log('d3:' + d3)

      // console.log('a3: ' + a3)
      // // console.log('b3: ' + b3) // 局部变量打印不出来
      // console.log('c3: ' + c3)

      /* 2018-11-20 九 this https://www.cnblogs.com/zichi/p/4359786.html  */
      /**
      测试this对象：
      第一次输出很好理解，第二次的话仔细看，this其实已经指向了this.m_Element，
      因为是this.m_Element调用的addEventListener函数，所以内部的this全指向它了。
      可以试着加上一行代码this.m_Element.m_Text = 'hello world'，就会alert出hello world了
      this可以看看这篇：https://www.cnblogs.com/lisha-better/p/5684844.html
      */
      function testThis2() {
        function JSClass() {
          this.m_Text = 'division element'
          this.m_Element = document.createElement('div')
          this.m_Element.innerHTML = this.m_Text
          this.m_Element.addEventListener('click', this.func)
        }

        JSClass.prototype.Render = function() {
          document.body.appendChild(this.m_Element)
        }

        JSClass.prototype.func = function() {
          console.log('func:' + this.m_Text)
        }

        var jc = new JSClass()
        // jc.Render()
        jc.func()
      }

      /** ------------------------------------- END function 笔试题 --------------------------------------------------------*/
      /** -------------------------------------START  Array 笔试题 --------------------------------------------------------*/
      /* 数组降维 -- 这里有三种方法 先阅读一遍 选择一种自己中意地方法 2018-11-16  https://www.cnblogs.com/front-end-ralph/p/4871332.html */
      /* 数组降维：方法一：把数组二层循环依次push到一个一维数组中 */
      /* 数组降维：方法二：利用concat + 循环 */
      function reduceDimention2(arr) {
        var reduced = []
        for (var i = 0; i < arr.length; i++) {
          reduced = reduced.concat(arr[i])
        }
        return reduced
      }
      /* 数组降维：方法三：利用apply和concat转换 */
      function reduceDimention3(arr) {
        // 相当于: [].concat(arr[0], arr[1]...)
        return Array.prototype.concat.apply([], arr)
      }

      /** -------------------------------------END  Array 笔试题 --------------------------------------------------------*/
      /** -------------------------------------START  string 笔试题（所有的测试和变量定义都放在闭包环境内 函数的调用可以放在外面） --------------------------------------------------------*/
      /* 2018-11-23 十 把URL参数解析为一个对象 https://www.cnblogs.com/zichi/p/4359786.html  */
      function parseQueryString() {
        var url = 'http://witmax.cn/index.php?key0=0&key1=1&key2=2'
        // 解析后的对象 -- 盛放的容器
        var obj = {}
        // 先取出参数部分 -- ?后面的部分  -- 利用split 其实 正则也能使用
        var queryStr = (url.split('?'))[1]
        // 将参数部分按照&分割
        var queryArr = queryStr.split('&')
        // 遍历&分割出来的 [key1=value1, key2=value2, ...]
        for (var i = 0; i < queryArr.length; i++) {
          // 对 key=value进行分割
          var kv = queryArr[i].split('=')
          // 将key=value分别填充到对象的key和对应的value中
          obj[kv[0]] = kv[1]
        }
        for (var k in obj) {
          console.log(k + ': ' + obj[k])
        }
      }

      /* 2018-11-23 七 统计字符串中出现最多的字符和次数 https://www.cnblogs.com/zichi/p/4359786.html  */
      /* 方法一：正则方法 */
      function statNumOfStrByReg() {
        var str = 'sdhiwfhsdhihihfihiohwdiwhifh'
        // 核心语句：匹配的就是'aabbcc'中的'aa' 'bb' 'cc'
        // 正则表达式中的小括号"()"。是代表分组的意思。 如果再其后面出现\1则是代表与第一个小括号中要匹配的内容相同。
        // 注意：\1必须与小括号配合使
        var  pattern = /(\w)\1*/g
        // 把字符串变成数组 排序 之后再变成字符串 -- 字符串排序
        var arr = str.split('').sort().join('')
        // match函数
        var ans = arr.match(pattern)
        // 对match后的数组进行降序排序
        ans.sort(function(a, b) {
          return b.length - a.length
        })
        // 下标为0的字符串就是最长的
        console.log('出现最多的字符是' + ans[0][0] + ', 出现了'  + ans[0].length + '次')
      }

      /* 方法二： Hash Table 统计字符串中出现最多的字符 */
      function statNumOfStrByHashTable() {
        var str = 'sdhiwfhiohwdiwhifh'
        // 准备一个设计好数据结构的对象 来存储我们对应的值 -- 利用的就是对象的同一key值不能重复
        // { letter1: length1, letter2: length2 ...}
        var obj = {};
        // 最大值 -- 容器
        var max = -1;
        // 出现最多的字符 -- 容器
        var letter;

        for (var i = 0; i < str.length; i++) {
          if (obj[str[i]]) {
            //当这个字段已经被统计 -- 该字段不是第一次出现
            obj[str[i]]++;
            // 如果这个字符是目前统计中出现次数最多的
            if (obj[str[i]] > max) {
              // 最大值更替为当前字符的出现次数
              max = obj[str[i]]
              // 出现最多的字符就是当前字符
              letter = str[i]
            }
          } else {
            // 这个字符还未被统计 -- 第一次出现
            obj[str[i]] = 1;
            if (obj[str[i]] > max) {
              max = obj[str[i]]
              letter = str[i]
            }           
          }
        }

        return '出现最多的是' + letter + '， 出现了' + max + '次'
      }
      /* 2018-11-13 https://www.cnblogs.com/dll-ft/p/5515692.html */
      /* 2018-11-15 查找字符串中出现次数最多的字符和次数 sdddrtkjsfkasjdddj中出现最多的字符是d,出现了6次 */
      function statMax(str) {
        var max = 0, // 出现的最大次数(max是一个不断修正的阈值 只在比之前max高时修改 只升不降)
            char, // 出现的最多的字符
            len = str.length || 0,
            json = {} // 核心是构造一个字符串对象，字符串的key对应的str[i]就是最大值，长度就是出现的次数
        // 
        for (var i = 0; i < len;i++) {
          if (!json[str[i]]) {
            // 当这个字符之前未出现 第一次出出现 json中设置这个属性
            json[str[i]] = str[i]
          } else {
            // 当这个字符第2+n次出现 则把这个字符加在json对应的key的value中 value是这个字符加起来的字符串 长度是该字符串目前为止出现的次数
            json[str[i]] += str[i]
          }
        }
        for (var  j = 0; j < len; j++) {
          // 当遍历到的json[str[i]]的长度大于max阈值时 修改max 记录当前最大的length -- 出现最多的次数
          if (json[str[j]].length > max) {
            max = json[str[j]].length
            char = str[j]
          }
        }
        console.log('出现次数最多的字符是'+char+',出现了'+max+'次')

        return {
          max: max,
          char: char
        }
      }
      /* 2018-11-13 字符串转驼峰 border-bottom-color ----> borderBottomColor */
      function toHump(str) {
        // 先把str变成数组
        var arr = str.split('-'), i
        // 利用循环对字符串数组处理
        for(i = 0; i < arr.length; i++) {
          arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1)
        }
        // 再把处理后的数组变成字符串
        return arr.join('')
      }
        /* 2018-11-13 字符串转驼峰 border-bottom-color ----> borderBottomColor */
        function toHump(str) {
        // 先把str变成数组
        var arr = str.split('-'), i
        // 利用循环对字符串数组处理
        for(i = 0; i < arr.length; i++) {
          arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1)
        }
        // 再把处理后的数组变成字符串
        return arr.join('')
      }
      /* 2018-11-8   https://blog.csdn.net/weixin_30363263/article/details/81503656 */
      /* 2018-11-8 统计字符串字节长度（汉字unicode码范围： [\u4e00 - \u9fa5]）对应汉字是[一 - 覦] 这个字念yu 四声 还是记编码吧哈哈 */
      function getStrBytesLen(str) {
        var len = str.length || 0,
            testReg = /[\u4e00-\u9f5a]/

        // 这里utf-8一般汉字为三个字节
        for (let i = 0; i < len; i++) {
          if (testReg.test(str[i])) {
            // 当前字符为汉字时 其还应加上额外的2个字节长度（一个汉字是3个字节 length中把一个汉字只统计为一个 所以这里要加2个）
            len += 2
          }
        }
        
        return len
      }
      /* 2018-11-9 数组去重 -- 这里利用的是对象不允许重复属性存在 - 【升级】 还可以把这个方法绑到Array.protoType上 当然 内部需要一些关于this的处理 */
      function noRepeat(arr) {
        arr = arr || []
        var result = []
        var json = {}
        // 把数组变成以数组值为key的json对象 
        for (var i = 0; i < arr.length; i++) {
          json[arr[i]] = arr[i]
        }
        // 把json对象转换成数组
        (function() {
          for (key in json) {
            result.push(key)
          }
        })()
        console.log('result：' + result)
        // 返回新的数组
        return result
      }
      
/** -------------------------------------END  string 笔试题（所有的测试和变量定义都放在闭包环境内 函数的调用可以放在外面） --------------------------------------------------------*/
      /** -------------------------------------  Object 笔试题 --------------------------------------------------------*/
      /** -------------------------------------  ES6 笔试题 --------------------------------------------------------*/
      /** -------------------------------------  异步 笔试题 --------------------------------------------------------*/
      /** -------------------------------------  闭包 笔试题 --------------------------------------------------------*/
      /* 2018-11-28 八 经典闭包 https://www.cnblogs.com/zichi/p/4359786.html */
      /* 变量污染法 */
      // links 集合返回当期文档所有链接的数组
      // var lis = document.links
      // for (var i = 0, length = lis.length; i < length; i++) {
      //   lis[i].index = i + 1;
      //   lis[i].onclick = function() {
      //     alert(this.index)
      //   }
      // }
      /* 闭包 */
      function closure() {
        var lis = document.links
        for (var i = 0, length = lis.length; i < length; i++) {
          lis[i].index = i + 1;
          (function(i) {
            lis[i].onclick = function() {
              alert( i + 1 )
            }
          })(i)
        }
      }
      /** -------------------------------------  算法 笔试题 --------------------------------------------------------*/
      /** -------------------------------------  test 函数执行区 --------------------------------------------------------*/
      // noRepeat([1, 2, 3, 4, 1, 3, 5, 1, 2, 7, 4, 8])
      // console.log('字符串字节数统计', getStrBytesLen('15678865我是解放军'))
      // console.log('toHump:', toHump('border-bottom-color'))
      // console.log('statMax:', statMax('sdddrtkjsfkasjdddj'))
      // console.log('reduceDimention2:', reduceDimention2([[1, 2], [3, 4], [5, 6]]))
      // console.log('reduceDimention3:', reduceDimention3([[1, 2], [3, 4], [5, 6]]))
      // console.log('testThis:', testThis())
      // console.log('testVar: ', testVar(1))
      // console.log('statNumOfStrByReg', statNumOfStrByReg())
      // console.log('statNumOfStrByHashTable', statNumOfStrByHashTable())
      // console.log('parseQueryString', parseQueryString())
      // console.log('testThis2: ' +  testThis2())
      console.log('closure: ' + closure())
    </script>
  </body>
</html>